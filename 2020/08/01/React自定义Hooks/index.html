<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Rex Wang">
    
    <title>
        
            React自定义Hooks |
        
        Rex&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/avatar.jpeg">
    
<link rel="stylesheet" href="/fontawesome/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/css/regular.min.css">

    
<link rel="stylesheet" href="/fontawesome/css/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/css/brands.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"rexking.me","root":"/","language":"en"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":false},"style":{"primary_color":"#d48b41","logo":"/images/avatar.jpeg","favicon":"/images/avatar.jpeg","avatar":"/images/avatar.jpeg","font_size":null,"font_family":null,"hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"header_transparent":true,"background_img":"/images/bg.svg","description":"What happens here, stays here.","font_color":null,"hitokoto":false},"scroll":{"progress_bar":true,"percent":false}},"local_search":{"enable":false,"preload":false},"code_copy":{},"code_block":{"tools":{"enable":false,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":false},"lazyload":{"enable":false},"comment":{"enable":true,"use":"gitalk","valine":{"appid":null,"appkey":null,"placeholder":null},"gitalk":{"github_id":"Wster11","github_admins":["Wster11"],"repository":"gitalk","client_id":"c1066502745b5039f0b3","client_secret":"3f28cf9eeabae08e04501f1289d0635d1a5b870f"},"twikoo":{"env_id":null,"region":null,"version":"1.6.7"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":true,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":false,"wordcount":false,"min2read":false},"img_align":"left","copyright_info":false},"version":"3.5.2"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"};
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/avatar.jpeg">
                </a>
            
            <a class="logo-title" href="/">
               Rex&#39;s Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">React自定义Hooks</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/avatar.jpeg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">Rex Wang</span>
                            
                                <span class="author-label">Lv1</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2020-08-01 17:48:44</span>
        <span class="mobile">2020-08-01 17:48</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2023-04-20 14:18:02</span>
    </span>
    
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/React/">React</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                <h1 id="自定义Hooks"><a href="#自定义Hooks" class="headerlink" title="自定义Hooks"></a>自定义Hooks</h1><blockquote>
<p>自定义 Hook 是 React Hooks 中最有趣的功能，或者说特色。简单来说，它用一种高度灵活的方式，能够让你在不同的函数组件之间共享某些特定的逻辑。</p>
</blockquote>
<h2 id="一个简单的自定义-Hooks"><a href="#一个简单的自定义-Hooks" class="headerlink" title="一个简单的自定义 Hooks"></a>一个简单的自定义 Hooks</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="comment">// 自定义hook useMousePostion</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useMousePostion</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 使用hookuseState初始化一个state</span></span><br><span class="line">    <span class="keyword">const</span> [postion, setPostion] = <span class="title function_">useState</span>(&#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;);</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">handleMove</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="title function_">setPostion</span>(&#123; <span class="attr">x</span>: e.<span class="property">clientX</span>, <span class="attr">y</span>: e.<span class="property">clientY</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用useEffect处理class中生命周期可以做到的事情</span></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 同时可以处理 componentDidMount 以及 componentDidUpdate 中的事情</span></span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, handleMove);</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`(<span class="subst">$&#123;postion.x&#125;</span>,<span class="subst">$&#123;postion.y&#125;</span>)`</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// return的function 可以相当于在组件被卸载的时候执行 类似于 componentWillUnmount</span></span><br><span class="line">            <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, handleMove);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// [] 是参数，代表deps，也就是说react触发这个hook的时机会和传入的deps有关，内部利用object.is实现</span></span><br><span class="line">        <span class="comment">// 默认不给参数会在每次render的时候调用，给空数组会导致每次比较是一样的，只执行一次，这里正确的应该是给postion</span></span><br><span class="line">    &#125;, [postion]);</span><br><span class="line">    <span class="comment">// postion 可以被直接return，这样达到了逻辑的复用~，哪里需要哪里调用就可以了。</span></span><br><span class="line">    <span class="keyword">return</span> postion;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useMousePostion</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过观察，我们可以发现自定义 Hook 具有以下特点：</p>
</blockquote>
<ul>
<li>表面上：一个命名格式为 useXXX 的函数，但不是 React 函数式组件</li>
<li>本质上：内部通过使用 React 自带的一些 Hook （例如 useState 和 useEffect ）来实现某些通用的逻辑</li>
</ul>
<p>有很多地方可以去做自定义 Hook：DOM 副作用修改&#x2F;监听、动画、请求、表单操作、数据存储等等。</p>
<blockquote>
<p>推荐两个强大的 React Hooks 库：React Use 和 Umi Hook。它们都实现了很多生产级别的自定义 </p>
</blockquote>
<h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><blockquote>
<p>依赖数组在判断元素是否发生改变时使用了 Object.is 进行比较，因此当 deps 中某一元素为非原始类型时（例如函数、对象等），每次渲染都会发生改变，从而每次都会触发 Effect，失去了 deps 本身的意义。</p>
</blockquote>
<p>关于 Effect 无限循环</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useEndlessCounter</span>(<span class="params">&#123; converter = data =&gt; data &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [counter, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="title function_">converter</span>(counter));</span><br><span class="line">  &#125;, [converter]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们的组件陷入了：渲染 &#x3D;&gt; 触发 Effect &#x3D;&gt; 修改状态 &#x3D;&gt; 触发重渲染的无限循环。</p>
<p>我们知道，在 JavaScript 中，原始类型和非原始类型在判断值是否相同的时候有巨大的差别：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始类型</span></span><br><span class="line"><span class="literal">true</span> === <span class="literal">true</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> === <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span> === <span class="string">&#x27;a&#x27;</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非原始类型</span></span><br><span class="line">&#123;&#125; === &#123;&#125; <span class="comment">// false</span></span><br><span class="line">[] === [] <span class="comment">// false</span></span><br><span class="line">() =&gt; &#123;&#125; === <span class="function">() =&gt;</span> &#123;&#125; <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同样，每次传入的 converter 函数虽然形式上一样，但仍然是不同的函数（引用不相等），从而导致每次都会执行 Effect 函数</p>
<h3 id="关于记忆化缓存（Memoization）"><a href="#关于记忆化缓存（Memoization）" class="headerlink" title="关于记忆化缓存（Memoization）"></a>关于记忆化缓存（Memoization）</h3><p>Memoization，一般称为记忆化缓存（或者“记忆”），听上去是很高深的计算机专业术语，但是它背后的思想很简单：假如我们有一个计算量很大的纯函数（给定相同的输入，一定会得到相同的输出），那么我们在第一次遇到特定输入的时候，把它的输出结果“记”（缓存）下来，那么下次碰到同样的输出，只需要从缓存里面拿出来直接返回就可以了，省去了计算的过程！</p>
<p>实际上，除了节省不必要的计算、从而提高程序性能之外，Memoization 还有一个用途：用了保证返回值的引用相等。</p>
<p>我们先通过一段简单的求平方根的函数，熟悉一下 Memoization 的原理。首先是一个没有缓存的版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sqrt</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">result</span>: <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(arg) &#125;;  <span class="comment">//返回对象和后面缓存版本做对比</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>缓存版本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">memoizedSqrt</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果 cache 不存在，则初始化一个空对象</span></span><br><span class="line">  <span class="keyword">if</span> (!memoizedSqrt.<span class="property">cache</span>) &#123;</span><br><span class="line">    memoizedSqrt.<span class="property">cache</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 cache 没有命中，则先计算，再存入 cache，然后返回结果</span></span><br><span class="line">  <span class="keyword">if</span> (!memoizedSqrt.<span class="property">cache</span>[arg]) &#123;</span><br><span class="line">    <span class="keyword">return</span> memoizedSqrt.<span class="property">cache</span>[arg] = &#123; <span class="attr">result</span>: <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(arg) &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接返回 cache 内的结果，无需计算</span></span><br><span class="line">  <span class="keyword">return</span> memoizedSqrt.<span class="property">cache</span>[arg];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果对比:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title function_">sqrt</span>(<span class="number">9</span>)                      <span class="comment">// &#123; result: 3 &#125;</span></span><br><span class="line"><span class="title function_">sqrt</span>(<span class="number">9</span>) === <span class="title function_">sqrt</span>(<span class="number">9</span>)          <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title function_">sqrt</span>(<span class="number">9</span>), <span class="title function_">sqrt</span>(<span class="number">9</span>))  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">memoizedSqrt</span>(<span class="number">9</span>)                              <span class="comment">// &#123; result: 3 &#125;</span></span><br><span class="line"><span class="title function_">memoizedSqrt</span>(<span class="number">9</span>) === <span class="title function_">memoizedSqrt</span>(<span class="number">9</span>)          <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title function_">memoizedSqrt</span>(<span class="number">9</span>), <span class="title function_">memoizedSqrt</span>(<span class="number">9</span>))  <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>普通的 sqrt 每次返回的结果的引用都不相同（或者说是一个全新的对象），而 memoizedSqrt 则能返回完全相同的对象。因此在 React 中，通过 Memoization 可以确保多次渲染中的 Prop 或者状态的引用相等，从而能够避免不必要的重渲染或者副作用执行。</p>
<p>让我们来总结一下记忆化缓存（Memoization）的两个使用场景：</p>
<ul>
<li>通过缓存计算结果，节省费时的计算</li>
<li>保证相同输入下返回值的引用相等</li>
</ul>
<blockquote>
<p>为了解决函数在多次渲染中的引用相等（Referential Equality）问题，React 引入了一个重要的 Hook—— useCallback</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = <span class="title function_">useCallback</span>(callback, deps);</span><br></pre></td></tr></table></figure>

<p>第一个参数 callback 就是需要记忆的函数，第二个参数就是大家熟悉的 deps 参数，同样也是一个依赖数组（有时候也被称为输入 inputs）。在 Memoization 的上下文中，这个 deps 的作用相当于缓存中的键（Key），如果键没有改变，那么就直接返回缓存中的函数，并且确保是引用相同的函数。</p>
<p>在大多数情况下，我们都是传入空数组 [] 作为 deps 参数，这样 useCallback 返回的就始终是同一个函数，永远不会更新。</p>
<blockquote>
<p>在学习 useEffect 的时候发现：我们并不需要把 useState 返回的第二个 Setter 函数作为 Effect 的依赖。实际上，React 内部已经对 Setter 函数做了 Memoization 处理，因此每次渲染拿到的 Setter 函数都是完全一样的，deps 加不加都是没有影响的。</p>
</blockquote>
<h3 id="useCallback-和-useMemo-的关系"><a href="#useCallback-和-useMemo-的关系" class="headerlink" title="useCallback 和 useMemo 的关系"></a>useCallback 和 useMemo 的关系</h3><p>useCallback 有个好基友叫 useMemo, useCallback 主要是为了解决函数的”引用相等“问题，而 useMemo 则是一个”全能型选手“，能够同时胜任引用相等和节约计算的任务</p>
<p>useMemo 的使用方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">fn</span>(a, b), [a, b]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中第一个参数是一个函数，这个函数返回值的返回值 将返回给 memoizedValue 。因此以下两个钩子的使用是完全等价的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useCallback</span>(fn, deps);</span><br><span class="line"><span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> fn, deps);</span><br></pre></td></tr></table></figure>
<p>然后我们用 useCallback 去解决上面计数器无限循环的问题并且去看一个 useMemo 性能优化案例</p>
<h2 id="useReducer-和-useContext"><a href="#useReducer-和-useContext" class="headerlink" title="useReducer 和 useContext"></a>useReducer 和 useContext</h2><p>useState 一个未解决的问题</p>
<p>你很有可能在使用 useState 的时候遇到过一个问题：通过 Setter 修改状态的时候，怎么读取上一个状态值，并在此基础上修改呢？如果你看文档足够细致，应该会注意到 useState 有一个函数式更新（Functional Update）的用法，以下面这段计数器（代码来自 React 官网）为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params">&#123;initialCount&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(initialCount);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      Count: &#123;count&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(initialCount)&#125;&gt;Reset<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到，我们传入 setCount 的是一个函数，它的参数是之前的状态，返回的是新的状态,这其实就是一个 Reducer 函数</p>
</blockquote>
<h3 id="Reducer-函数"><a href="#Reducer-函数" class="headerlink" title="Reducer 函数"></a>Reducer 函数</h3><p>我们这里将先回归最基础的概念，暂时忘掉框架相关的知识。在学习 JavaScript 基础时，你应该接触过数组的 reduce 方法，它可以用一种相当炫酷的方式实现数组求和：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> value = nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, next</span>) =&gt;</span> acc + next, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中 reduce 的第一个参数 (acc, next) &#x3D;&gt; acc + next 就是一个 Reducer 函数。从表面上来看，这个函数接受一个状态的累积值 acc 和新的值 next，然后返回更新过后的累积值 acc + next</p>
<p>从更深层次来说，Reducer 函数有两个必要规则：</p>
<ul>
<li>只返回一个值</li>
<li>不修改输入值，而是返回新的值</li>
</ul>
<p>第一点很好判断，其中第二点则是很多新手踩过的坑，对比以下两个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 不是 Reducer 函数！ push会改变原数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">buy</span>(<span class="params">cart, thing</span>) &#123;</span><br><span class="line">  cart.<span class="title function_">push</span>(thing);</span><br><span class="line">  <span class="keyword">return</span> cart;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正宗的 Reducer 函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">buy</span>(<span class="params">cart, thing</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> cart.<span class="title function_">concat</span>(thing);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用数组的 push 方法，会就地修改输入的 cart 参数（是否 return 都无所谓了），违反了 Reducer 第二条规则，而下面的函数通过数组的 concat 方法返回了一个全新的数组，避免了直接修改 cart</p>
<p>此时我们在看 useState 的函数式写法 是一个很标准的 reducer 函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setCount</span>(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>我们在之前大量地使用了 useState，你可能就此认为 useState 应该是最底层的元素了。但实际上在 React 的源码中，useState 的实现使用了 useReducer</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">basicStateReducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span> ? <span class="title function_">action</span>(state) : action;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="useReducer-使用浅析"><a href="#useReducer-使用浅析" class="headerlink" title="useReducer 使用浅析"></a>useReducer 使用浅析</h3><p>官方介绍的 reducer 用法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialArg, init);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先我们来看下 useReducer 需要提供哪些参数：</p>
<p>第一个参数 reducer 显然是必须的，它的形式跟 Redux 中的 Reducer 函数完全一致，即 (state, action) &#x3D;&gt; newState<br>第二个参数 initialArg 就是状态的初始值<br>第三个参数 init 是一个可选的用于懒初始化（Lazy Initialization）的函数，这个函数返回初始化后的状态<br>返回的 state（只读状态）和 dispatch（派发函数）则比较容易理解了。我们来结合一个简单的计数器例子讲解一下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reducer 函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      Count: &#123;state.count&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;increment&#x27; &#125;)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们首先关注一下 Reducer 函数，它的两个参数 state 和 action 分别是当前状态和 dispatch 派发的动作。这里的动作就是普通的 JavaScript 对象，用来表示修改状态的操作，注意 type 是必须要有的属性，代表动作的类型。然后我们根据 action 的类型返回相应修改后的新状态。</p>
<p>然后在 Counter 组件中，我们通过 useReducer 钩子获取到了状态和 dispatch 函数，然后把这个状态渲染出来。在按钮 button 的 onClick 回调函数中，我们通过 dispatch 一个类型为 increment 的 Action 去更新状态。</p>
<h3 id="什么时候使用-useReducer"><a href="#什么时候使用-useReducer" class="headerlink" title="什么时候使用 useReducer"></a>什么时候使用 useReducer</h3><p>你也许发现，useReducer 和 useState 的使用目的几乎是一样的：定义状态和修改状态的逻辑。useReducer 使用起来较为繁琐，但如果你的状态管理出现了至少一个以下所列举的问题：</p>
<ul>
<li>需要维护的状态本身比较复杂，多个状态之间相互依赖</li>
<li>修改状态的过程比较复杂</li>
</ul>
<p>就强烈建议你使用 useReducer 了<br>假设我们要做一个支持撤销和重做的编辑器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 用于懒初始化的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">init</span>(<span class="params">initialState</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">past</span>: [],</span><br><span class="line">    <span class="attr">present</span>: initialState,</span><br><span class="line">    <span class="attr">future</span>: [],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reducer 函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; past, future, present &#125; = state;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;UNDO&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">past</span>: past.<span class="title function_">slice</span>(<span class="number">0</span>, past.<span class="property">length</span> - <span class="number">1</span>),</span><br><span class="line">        <span class="attr">present</span>: past[past.<span class="property">length</span> - <span class="number">1</span>],</span><br><span class="line">        <span class="attr">future</span>: [present, ...future],</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;REDO&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">past</span>: [...past, present],</span><br><span class="line">        <span class="attr">present</span>: future[<span class="number">0</span>],</span><br><span class="line">        <span class="attr">future</span>: future.<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果用useState来写是比较困难的</p>
<h2 id="useContext-使用浅析"><a href="#useContext-使用浅析" class="headerlink" title="useContext 使用浅析"></a>useContext 使用浅析</h2><p>在 Hooks 诞生之前，React 已经有了在组件树中共享数据的解决方案：Context在类组件中，我们可以通过 createContext 属性获取到最近的 Context Provider</p>
<p>从 API 名字就可以看出， createContext 能够创建一个 React 的 上下文（context），然后订阅了这个上下文的组件中，可以拿到上下文中提供的数据或者其他信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(defaultValue)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 useContext 获取上下文</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从上面代码可以发现，useContext 需要将 MyContext 这个 Context 实例传入，不是字符串，就是实例本身。</span></span><br><span class="line"><span class="keyword">const</span> &#123;funcName&#125; = <span class="title function_">useContext</span>(<span class="title class_">MyContext</span>);</span><br></pre></td></tr></table></figure>

<p>这种用法会存在一个比较尴尬的地方，父子组件不在一个目录中，如何共享 MyContext 这个 Context 实例呢？</p>
<p>一般这种情况下，会通过 Context Manager 统一管理上下文的实例，然后通过 export 将实例导出，在子组件中在将实例 import 进来。</p>
<p>案例: createContext 和 useContext 结合使用实现方法共享</p>
<blockquote>
<p>举个实际的例子：子组件中修改父组件的 state, 一般的做法是将父组件的方法比如 setXXX 通过 props 的方式传给子组件，而一旦子组件多层级的话，就要层层透传。<br>使用 Context 的方式则可以免去这种层层透传</p>
</blockquote>
<p>1、context-manager.js<br>创建一个上下文管理的组件，用来统一导出 Context 实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>2、下面代码中，父组件引入了实例，并且通过 MyContext.Provider 将父组件包装，并且通过 Provider.value 将方法提供出去。</p>
<p>下面的实例提供了三个 state 操作方法：</p>
<p>setStep<br>setCount<br>setNumber<br>以及一个副作用方法：</p>
<p>fetchData<br>使用 useReducer 减少 Context 的复杂程度</p>
<p>3、子组件 useContext 解析上下文</p>
<p>下面是子组件，相同的，也需要从 context-manager 中引入 MyContext 这个实例，然后才能通过 const { setStep, setNumber, setCount, fetchData } &#x3D; useContext(MyContext); 解析出上下文中的方法，在子组件中则可以直接使用这些方法，修改父组件的 state。</p>
<p>4、使用 useReducer 减少 Context 的复杂程度</p>
<p>上面的示例虽然实现了多级组件方法共享，但是暴露出一个问题：所有的方法都放在了 Context.Provider.value 属性中传递，必然造成整个 Context Provider 提供的方法越来越多，也会臃肿。<br>而像 setStep、setCount、setNumber 这三个方法，是可以通过 useReducer 包装，并且通过 dispatch 触发的，因此修改一下父组件：</p>
<p>5、将 state 也通过 Context 传递给子组件</p>
<p>上面的所有示例中，子组件获取父组件的 state 还是通过 props ，多级子组件又会存在层层嵌套<br>如果将整个 state 通过 Context 传入就无需层层组件的 props 传递（如果不需要整个state，可以只将某几个 state 给 Provider）</p>
<blockquote>
<p>直接使用父组件 state 带来的性能问题,在点击子组件的 【number + step】 按钮的时候，虽然 count 的值没有发生任何变化，但是一直触发 re-render，即使子组件是通过 React.memo 包装过的。<br>出现这个问题原因是 React.memo 只会对 props 进行浅比较，而通过 Context 我们直接将 state 注入到了组件内部，因此 state 的变化必然会触发 re-render，整个 state 变化是绕过了 memo。</p>
</blockquote>
<p>6、 使用 useMemo() 解决 state Context 透传的性能问题</p>
<blockquote>
<p>既然 React.memo() 无法拦截注入到 Context 的 state 的变化，那就需要我们在组件内部进行更细粒度的性能优化，这个时候可以使用 useMemo()</p>
</blockquote>

            </div>

            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/React/">#React</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/2022/10/20/%E5%9F%BA%E4%BA%8E%E7%8E%AF%E4%BF%A1IM30%E5%88%86%E9%92%9F%E5%BC%80%E5%8F%91%E5%8D%B3%E4%BD%BF%E9%80%9A%E8%AE%AF%E5%BA%94%E7%94%A8/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">基于环信IM30分钟开发即使通讯应用</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                            </a>
                        </div>
                    
                    
                </div>
            

            
                <div class="comment-container">
                    
<div class="comments-container">
    <div id="comments-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments"></i>&nbsp;Comments
    </div>
    
        
            

    <div class="gitalk-comment-container">
        <div id="gitalk-container"></div>
        <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk/dist/gitalk.css">
        <script  src="//cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script>
        <script >
          function loadGitalk() {
            let __gitalk__pathname = decodeURI(location.pathname);
            const __gitalk__pathnameLength = __gitalk__pathname.length;
            const __gitalk__pathnameMaxLength = 50;
            if (__gitalk__pathnameLength > __gitalk__pathnameMaxLength) {
              __gitalk__pathname = __gitalk__pathname.substring(0, __gitalk__pathnameMaxLength - 3) + '...';
            }

            try {
              Gitalk && new Gitalk({
                clientID: 'c1066502745b5039f0b3',
                clientSecret: '3f28cf9eeabae08e04501f1289d0635d1a5b870f',
                repo: 'gitalk',
                owner: 'Wster11',
                admin: 'Wster11',
                id: __gitalk__pathname,
                language: 'en'
              }).render('gitalk-container');
            } catch (e) {
              window.Gitalk = null;
            }
          }

          if ('false' === 'true') {
            const loadGitalkTimeout = setTimeout(() => {
              loadGitalk();
              clearTimeout(loadGitalkTimeout);
            }, 1000);
          } else {
            window.addEventListener('DOMContentLoaded', loadGitalk);
          }
        </script>
    </div>



        
    
</div>

                </div>
            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Hooks"><span class="nav-number">1.</span> <span class="nav-text">自定义Hooks</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89-Hooks"><span class="nav-number">1.1.</span> <span class="nav-text">一个简单的自定义 Hooks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#useCallback"><span class="nav-number">1.2.</span> <span class="nav-text">useCallback</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E8%AE%B0%E5%BF%86%E5%8C%96%E7%BC%93%E5%AD%98%EF%BC%88Memoization%EF%BC%89"><span class="nav-number">1.2.1.</span> <span class="nav-text">关于记忆化缓存（Memoization）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#useCallback-%E5%92%8C-useMemo-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.2.2.</span> <span class="nav-text">useCallback 和 useMemo 的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#useReducer-%E5%92%8C-useContext"><span class="nav-number">1.3.</span> <span class="nav-text">useReducer 和 useContext</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Reducer-%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.1.</span> <span class="nav-text">Reducer 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#useReducer-%E4%BD%BF%E7%94%A8%E6%B5%85%E6%9E%90"><span class="nav-number">1.3.2.</span> <span class="nav-text">useReducer 使用浅析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8-useReducer"><span class="nav-number">1.3.3.</span> <span class="nav-text">什么时候使用 useReducer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#useContext-%E4%BD%BF%E7%94%A8%E6%B5%85%E6%9E%90"><span class="nav-number">1.4.</span> <span class="nav-text">useContext 使用浅析</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2020</span> -
            
            2023
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">Rex Wang</a>
            
        </div>
        
        <!-- <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.5.2</a>
        </div> -->
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="tools-item flex-center go-to-comments">
                <i class="fas fa-comment"></i>
                <span class="post-comments-count"></span>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>










<div class="post-scripts">
    
        
<script src="/js/post-helper.js"></script>

        
            
<script src="/js/libs/anime.min.js"></script>

        
        
            
<script src="/js/toc.js"></script>

        
    
</div>



</body>
</html>
